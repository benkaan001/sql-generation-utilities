import os
import argparse
import sys
from typing import List, Tuple

# Define the standard BTEQ skeleton structure
BTEQ_SKELETON = """/*
-------------------------------------------------------------------------------
-- Script: {table_name}.sql
-- Purpose: BTEQ script skeleton for table {schema}.{table_name}
-- Generated By: Python Automation Script
-------------------------------------------------------------------------------
*/

.LOGON server/user,password;

DATABASE {schema};

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 10: Drop work/error tables
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 20: Create work/error tables
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 30: Primary Index check / Skew check (if applicable)
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 40: Insert data into work table
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 50: Collect statistics on work table
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 60: Delete target rows (if applicable)
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 70: Insert into target table from work table
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 80: Collect statistics on target table
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 90: Drop work/error tables
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

--<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-- STEP 100: Final counts / Sanity checks
--<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


.LOGOFF;
.EXIT;

/********************************************************* END *************************************************************************/
"""

def parse_table_list(file_path: str) -> List[Tuple[str, str]]:
    """
    Reads the input file and parses schema.table names, handling comments.

    Args:
        file_path: Path to the input text file.

    Returns:
        A list of tuples, where each tuple is (schema, table_name).
        Returns an empty list if the file cannot be read or is empty.
    """
    tables = []
    if not os.path.exists(file_path):
        print(f"Error: Input file not found at {file_path}", file=sys.stderr)
        return []

    try:
        with open(file_path, 'r') as f:
            for line_num, line in enumerate(f, 1):
                # Remove comments starting with # first
                line_no_comment = line.split('#', 1)[0]
                cleaned_line = line_no_comment.strip().lstrip(',') # Remove whitespace and potential leading comma

                if not cleaned_line:
                    continue # Skip empty or comment-only lines

                # Basic validation for format: must contain exactly one '.' and parts must not be empty
                if cleaned_line.count('.') != 1:
                    print(f"Warning: Skipping invalid line {line_num} (invalid '.' count): {line.strip()}", file=sys.stderr)
                    continue

                parts = cleaned_line.split('.', 1)
                schema = parts[0].strip()
                table_name = parts[1].strip()

                # Ensure schema and table name are not empty after stripping
                if schema and table_name:
                    tables.append((schema, table_name))
                else:
                     print(f"Warning: Skipping invalid line {line_num} (empty schema or table): {line.strip()}", file=sys.stderr)

    except IOError as e:
        print(f"Error: Could not read file {file_path}. Details: {e}", file=sys.stderr)
        return []
    except Exception as e:
        print(f"An unexpected error occurred while reading {file_path}: {e}", file=sys.stderr)
        return []

    return tables

def generate_sql_file(schema: str, table_name: str, output_dir: str) -> bool:
    """
    Generates a single BTEQ skeleton SQL file.

    Args:
        schema: The schema name.
        table_name: The table name.
        output_dir: The directory to save the SQL file.

    Returns:
        True if the file was created successfully, False otherwise.
    """
    # Ensure table name is suitable for a filename (basic cleaning)
    safe_table_name = "".join(c if c.isalnum() or c in ('_', '-') else '_' for c in table_name)
    if not safe_table_name:
        print(f"Error: Could not generate safe filename for table '{table_name}'", file=sys.stderr)
        return False

    sql_file_name = f"{safe_table_name}.sql"
    sql_file_path = os.path.join(output_dir, sql_file_name)
    content = BTEQ_SKELETON.format(schema=schema, table_name=table_name)

    try:
        with open(sql_file_path, 'w') as f:
            f.write(content)
        return True
    except IOError as e:
        print(f"Error: Could not write file {sql_file_path}. Details: {e}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred while writing {sql_file_path}: {e}", file=sys.stderr)
        return False

def main():
    """
    Main function to parse arguments and generate BTEQ skeleton files.
    """
    parser = argparse.ArgumentParser(description="Generate skeleton BTEQ SQL files from a list of tables.")
    parser.add_argument("-i", "--input", required=True, help="Path to the input text file listing tables (format: SCHEMA.TABLE).")
    parser.add_argument("-o", "--output-dir", required=True, help="Path to the directory where generated SQL files will be saved.")

    args = parser.parse_args()

    # Create output directory if it doesn't exist
    try:
        if not os.path.exists(args.output_dir):
            os.makedirs(args.output_dir)
            print(f"Created output directory: {args.output_dir}")
        elif not os.path.isdir(args.output_dir):
            print(f"Error: Output path {args.output_dir} exists but is not a directory.", file=sys.stderr)
            sys.exit(1)
    except OSError as e:
        print(f"Error: Could not create output directory {args.output_dir}. Details: {e}", file=sys.stderr)
        sys.exit(1)

    # Parse the input list
    table_list = parse_table_list(args.input)
    if not table_list:
        print("No valid tables found in the input file. Exiting.", file=sys.stderr)
        sys.exit(1) # Exit if no tables parsed

    print(f"Found {len(table_list)} tables. Generating SQL skeletons in {args.output_dir}...")

    # Generate files
    success_count = 0
    failure_count = 0
    for schema, table_name in table_list:
        if generate_sql_file(schema, table_name, args.output_dir):
            success_count += 1
        else:
            failure_count += 1

    print(f"\nGeneration complete.")
    print(f"Successfully created: {success_count} files.")
    if failure_count > 0:
        print(f"Failed to create: {failure_count} files.")
        sys.exit(1) # Indicate partial failure

if __name__ == "__main__":
    main()
